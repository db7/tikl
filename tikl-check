#!/bin/sh

set -u

sanitize_prefix() {
	printf "%s" "$1" | tr -c 'A-Za-z0-9_' '_'
}

add_prefix() {
	p=$1
	if [ -z "$p" ]; then
		echo "tikl-check: empty --check-prefix" >&2
		exit 2
	fi
	case "$p" in
		*[!A-Za-z0-9_-]*)
			echo "tikl-check: invalid prefix: $p" >&2
			exit 2
			;;
	esac
	if [ -z "${prefixes-}" ]; then
		prefixes="$p"
	else
		prefixes="$prefixes $p"
	fi
}

trim_leading() {
	printf "%s" "$1" | sed 's/^[[:space:]]*//'
}

escape_literal() {
	printf "%s" "$1" | sed 's/[].[^$\\*/+?{}()|]/\\&/g'
}

make_regex() {
	input=$1
	regex=""
	rest=$input
	while [ -n "$rest" ]; do
		case "$rest" in
			*'{{'*)
				lit=${rest%%'{{'*}
				if [ -n "$lit" ]; then
					regex="${regex}$(escape_literal "$lit")"
				fi
				rest=${rest#*'{{'}
				case "$rest" in
					*'}}'*)
						block=${rest%%'}}'*}
						regex="${regex}${block}"
						rest=${rest#*'}}'}
						;;
					*)
						echo "tikl-check: unterminated {{ in pattern: $input" >&2
						return 1
						;;
				esac
				;;
			*)
				regex="${regex}$(escape_literal "$rest")"
				rest=""
				;;
		esac
	done
	printf "%s" "$regex"
	return 0
}

get_last_line() {
	tag=$(sanitize_prefix "$1")
	var="last_line_${tag}"
	eval "printf '%s' \"\${$var:-0}\""
}

set_last_line() {
	tag=$(sanitize_prefix "$1")
	var="last_line_${tag}"
	eval "$var=$2"
}

get_have_last() {
	tag=$(sanitize_prefix "$1")
	var="have_last_${tag}"
	eval "printf '%s' \"\${$var:-0}\""
}

set_have_last() {
	tag=$(sanitize_prefix "$1")
	var="have_last_${tag}"
	eval "$var=$2"
}

usage() {
	echo "usage: tikl-check [--check-prefix=NAME]... TESTFILE" >&2
	exit 2
}

prefixes=""
testfile=""

while [ $# -gt 0 ]; do
	case "$1" in
		--check-prefix=*)
			add_prefix "${1#*=}"
			shift
			;;
		--check-prefix)
			shift
			[ $# -gt 0 ] || usage
			add_prefix "$1"
			shift
			;;
		--)
			shift
			break
			;;
		-*)
			echo "tikl-check: unknown option: $1" >&2
			exit 2
			;;
		*)
			if [ -z "$testfile" ]; then
				testfile="$1"
			else
				echo "tikl-check: unexpected argument: $1" >&2
				exit 2
			fi
			shift
			;;
	esac
done

if [ -z "$testfile" ] && [ $# -gt 0 ]; then
	testfile="$1"
	shift
fi

if [ -z "$testfile" ]; then
	usage
fi

if [ $# -gt 0 ]; then
	echo "tikl-check: unexpected argument: $1" >&2
	exit 2
fi

if [ -z "$prefixes" ]; then
	prefixes="CHECK"
fi

tmp=$(mktemp "${TMPDIR:-/tmp}/tikl-check.XXXXXX" 2>/dev/null)
if [ $? -ne 0 ] || [ -z "$tmp" ]; then
	tmp="${TMPDIR:-/tmp}/tikl-check.$$"
fi
trap 'rm -f "$tmp"' EXIT HUP INT TERM

cat >"$tmp"

status=0

check_forward() {
	prefix=$1
	pat=$2
	regex=$(make_regex "$pat") || {
		status=1
		return
	}
	last=$(get_last_line "$prefix")
	line=$(awk -v start="$last" -v regex="$regex" '
		NR > start && $0 ~ regex { print NR; found=1; exit }
		END { if(!found) exit 1 }
	' "$tmp")
	if [ $? -ne 0 ] || [ -z "$line" ]; then
		echo "tikl-check: missing pattern: $pat" >&2
		status=1
		return
	fi
	set_last_line "$prefix" "$line"
	set_have_last "$prefix" 1
}

check_next() {
	prefix=$1
	pat=$2
	regex=$(make_regex "$pat") || {
		status=1
		return
	}
	have=$(get_have_last "$prefix")
	if [ "$have" -eq 0 ]; then
		echo "tikl-check: ${prefix}-NEXT without prior match" >&2
		status=1
		return
	fi
	last=$(get_last_line "$prefix")
	exp=$((last + 1))
	line=$(awk -v expected="$exp" -v regex="$regex" '
		NR == expected && $0 ~ regex { print NR; found=1; exit }
		END { if(!found) exit 1 }
	' "$tmp")
	if [ $? -ne 0 ] || [ -z "$line" ]; then
		echo "tikl-check: ${prefix}-NEXT failed on line $exp for: $pat" >&2
		status=1
		return
	fi
	set_last_line "$prefix" "$line"
	set_have_last "$prefix" 1
}

check_same() {
	prefix=$1
	pat=$2
	regex=$(make_regex "$pat") || {
		status=1
		return
	}
	have=$(get_have_last "$prefix")
	if [ "$have" -eq 0 ]; then
		echo "tikl-check: ${prefix}-SAME without prior match" >&2
		status=1
		return
	fi
	target=$(get_last_line "$prefix")
	line=$(awk -v target="$target" -v regex="$regex" '
		NR == target && $0 ~ regex { print NR; found=1; exit }
		END { if(!found) exit 1 }
	' "$tmp")
	if [ $? -ne 0 ] || [ -z "$line" ]; then
		echo "tikl-check: ${prefix}-SAME failed on line $target for: $pat" >&2
		status=1
		return
	fi
}

check_empty() {
	prefix=$1
	have=$(get_have_last "$prefix")
	if [ "$have" -eq 0 ]; then
		exp=1
	else
		last=$(get_last_line "$prefix")
		exp=$((last + 1))
	fi
	line=$(awk -v expected="$exp" '
		NR == expected && $0 == "" { print NR; found=1; exit }
		END { if(!found) exit 1 }
	' "$tmp")
	if [ $? -ne 0 ] || [ -z "$line" ]; then
		echo "tikl-check: ${prefix}-EMPTY failed on line $exp" >&2
		status=1
		return
	fi
	set_last_line "$prefix" "$line"
	set_have_last "$prefix" 1
}

check_count() {
	target_count=$1
	pat=$2
	regex=$(make_regex "$pat") || {
		status=1
		return
	}
	found=$(awk -v regex="$regex" '
		$0 ~ regex { count++ }
		END { print count + 0 }
	' "$tmp")
	if [ "$found" != "$target_count" ]; then
		echo "tikl-check: CHECK-COUNT expected $target_count, got $found for: $pat" >&2
		status=1
	fi
}

check_not() {
	pat=$1
	regex=$(make_regex "$pat") || {
		status=1
		return
	}
	if awk -v regex="$regex" '
		$0 ~ regex { found=1; exit }
		END { if(found) exit 0; exit 1 }
	' "$tmp"; then
		echo "tikl-check: unexpected pattern: $pat" >&2
		status=1
	fi
}

while IFS= read -r line || [ -n "$line" ]; do
	for prefix in $prefixes; do
		if [ "${line#*${prefix}-NEXT:}" != "$line" ]; then
			content=${line#*${prefix}-NEXT:}
			pattern=$(trim_leading "$content")
			check_next "$prefix" "$pattern"
			break
		fi
		if [ "${line#*${prefix}-SAME:}" != "$line" ]; then
			content=${line#*${prefix}-SAME:}
			pattern=$(trim_leading "$content")
			check_same "$prefix" "$pattern"
			break
		fi
		if [ "${line#*${prefix}-EMPTY:}" != "$line" ]; then
			check_empty "$prefix"
			break
		fi
		if [ "${line#*${prefix}-COUNT:}" != "$line" ]; then
			content=${line#*${prefix}-COUNT:}
			content=$(trim_leading "$content")
			count=${content%%[!0-9]*}
			rest=${content#"$count"}
			rest=$(trim_leading "$rest")
			if [ -z "$count" ] || ! printf "%s" "$count" | grep -Eq '^[0-9]+$'; then
				echo "tikl-check: invalid ${prefix}-COUNT directive: $content" >&2
				status=1
			else
				check_count "$count" "$rest"
			fi
			break
		fi
		if [ "${line#*${prefix}-NOT:}" != "$line" ]; then
			content=${line#*${prefix}-NOT:}
			pattern=$(trim_leading "$content")
			check_not "$pattern"
			break
		fi
		if [ "${line#*${prefix}:}" != "$line" ]; then
			content=${line#*${prefix}:}
			pattern=$(trim_leading "$content")
			check_forward "$prefix" "$pattern"
			break
		fi
	done
done < "$testfile"

exit $status
